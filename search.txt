docker daemon
docker file
docker registry (public or private)
docker build -t 
docker compose

Docker uses an HTTP-based REST API to communicate between the Docker client and the Docker daemon, usually over a Unix socket, and optionally over TCP.
we can send a http request to the socket using curl to see the running container => curl --unix-socket /var/run/docker.sock http://localhost/containers/json

containerd = page 47 - 48
shim = page 47
runc = page 47 - 48

containerd :  (pronounced container-dee). Its sole purpose in life was to manage container lifecycle operations â€” start | stop | pause | rm....

shim : Keeps the container alive, If dockerd crashes => container keeps running shim is still there

run : runc has a single purpose in life â€” create containers. And itâ€™s damn good at it.


Who runc is work ?

Here is what runc does:

Sets up namespaces (PID, network, mount, etc.)

Applies cgroups (CPU/memory limits)

Sets up root filesystem

Executes the container process

runc is the low-level runtime that talks directly to the Linux kernel.







docker CLI
   |
   |  HTTP / REST
   |  (over Unix socket or TCP)
   v
Docker Engine API (dockerd)
   |
   |  gRPC
   v
containerd
   |
   |  gRPC
   v
runc (OCI runtime)



7ï¸âƒ£ What is a dangling image?
When you rebuild an image with the same tag:

Example:

docker build -t app:latest .


Then rebuild again:

docker build -t app:latest .


Docker:

Creates a new image

Moves tag app:latest to new image

Old image loses its tag

Now old image becomes:

<none>:<none>


That is a dangling image.

View dangling images
docker image ls --filter dangling=true

Remove them
docker image prune


Add -a to remove all unused images.




EXPLAIN THIS DOCKERFILE:
# 1ï¸âƒ£ Base image 
FROM node:20-alpine 
# 2ï¸âƒ£ Set working directory 
WORKDIR /app 
# 3ï¸âƒ£ Copy project files 
COPY app.js . 
# 4ï¸âƒ£ Command to run 
CMD ["node app.js && ls"]

Dockerfile Explanation

FROM node:20-alpine Defines the base image. It uses Node.js version 20
on Alpine Linux. This provides the operating system and Node.js runtime
needed to run the application.

WORKDIR /app Sets the working directory inside the container to /app.
All following commands will run in this directory. Docker creates it
automatically if it does not exist.

COPY app.js . Copies the file app.js from the host machine into the
containerâ€™s working directory (/app). This adds the application code to
the image.

CMD [â€œnode app.js && lsâ€] Defines the default command that runs when the
container starts. However, this syntax is incorrect for multiple
commands because it does not use a shell. The correct form should be:
CMD [â€œnodeâ€, â€œapp.jsâ€] or CMD sh -c â€œnode app.js && lsâ€

Summary: - FROM: defines the base environment - WORKDIR: sets the
working directory - COPY: adds files into the image - CMD: defines the
startup command



WHAT IS IMAGE LAYER?
A Docker image layer is a read-only filesystem snapshot created by each instruction in a Dockerfile. Layers are stacked on top of each other to form the final image, and the combination of all layers appears as a single unified filesystem in the container.

Key points in short:

Layers are read-only.

Layers are reusable across images.

The top writable layer exists only in running containers.

Layers make builds faster and storage efficient.


Images and layers:
A Docker image is just a bunch of loosely-connected read-only layers, with each layer comprising one or more
files.

===========> to know how many layer we have in image we need to pull one as example and see how many have this word "Pull complete" the number of word is the also number of layers
example: docker image pull ubuntu:latest | grep "Pull complete" | wc -l
you can also do this command => docker image inspect ubuntu:latest =======> this command  Display detailed information of an image =====> after that you can search on layers and count how many layers we have in this image
we have a also this command ====> docker image history ubuntu:latest this Show the history of an image and you can see the layers of image ====> However, it shows
the build history of an image and is not a strict list of layers in the final image.


ğŸ§± 1ï¸âƒ£ The Base Layer (Ubuntu 20.04)

You start with:

FROM ubuntu:20.04


This is your base layer.

Important:
Ubuntu itself is NOT one single layer.
It is already built from multiple internal layers.

But logically, for your image, we treat it as:

Layer 1 â†’ Ubuntu 20.04


This layer contains:

/bin

/usr

/lib

system packages

core Linux files

It is read-only.

ğŸ§± 2ï¸âƒ£ Add Python (Second Layer)

Then your Dockerfile has:

RUN apt update && apt install -y python3


This creates a new layer on top.

This layer contains:

New Python binaries

Python libraries

Updated apt metadata

Modified filesystem content

Now your image looks like this:

Layer 2 â†’ Python installed
Layer 1 â†’ Ubuntu 20.04


Important concept:

ğŸ‘‰ Layer 2 does NOT copy all of Ubuntu.
ğŸ‘‰ It only stores the filesystem changes.

This is extremely important.

ğŸ§± 3ï¸âƒ£ Add Application Source Code

Then:

COPY app.py /app/app.py


This creates another layer.

Now your image:

Layer 3 â†’ app.py
Layer 2 â†’ Python installed
Layer 1 â†’ Ubuntu


So you now have:

3 layers (oversimplified example).
















ğŸ§  Step 1 â€” Imagine This

You download a movie file.

If someone changes even one pixel, the file becomes different.

How can you prove itâ€™s the exact same file?

ğŸ‘‰ You calculate a hash.

That hash is like:

A BIG UNIQUE FINGERPRINT


If file changes â†’ fingerprint changes.

That fingerprint = digest.

ğŸ³ Now In Docker

When you pull:

docker pull alpine:latest


You are asking for:

Repository: alpine

Tag: latest

But here is the problem:

âš ï¸ latest can change.

Today it points to version 1.
Tomorrow it may point to version 2.

ğŸ¯ So What Is Digest?

Digest is the real identity of the image.

Example:

alpine@sha256:abc123....


That long sha256:... is the digest.

It is calculated from the image content.

If anything changes in the image â†’ digest changes.

So digest = exact version forever.

ğŸ†š Tag vs Digest (Very Simple)

Think like this:

Tag = nickname
Digest = national ID card number

Nicknames can change.
ID number never changes.

ğŸ“¦ Example From Real Life

Run:

docker pull alpine


You will see something like:

Digest: sha256:9cacb71397b...


That means:

The real identity of the image you downloaded is:

sha256:9cacb71397b...


Even if latest changes tomorrow,
that digest will always point to that exact image.



ğŸ”´ Problem 1: Tags Can Be Changed

Imagine this timeline:

Day 1

You run:

docker pull myapp:latest


latest â†’ points to image A
Digest = sha256:AAA

Everything works fine.

Day 5

The developer pushes a new version and re-tags it:

myapp:latest â†’ now points to image B
Digest = sha256:BBB


You run:

docker pull myapp:latest


Now you get image B.

âš ï¸ Same tag.
âš ï¸ Different image.
âš ï¸ Different behavior.

This is dangerous in production.

ğŸ”’ Why Digest Solves This

Digest is calculated from the image content using SHA256.

That means:

If even ONE BIT changes â†’ digest changes completely.

Example:

Image A â†’ sha256:AAA
Image B â†’ sha256:BBB


They can NEVER have the same digest unless they are identical.

So if you pull using digest:

docker pull myapp@sha256:AAA


You are guaranteed to get EXACTLY image A.

Forever.



What is docker compose?
Docker Compose is a tool for defining and running multi-container applications. It is the key to unlocking a streamlined and efficient development and deployment experience.

Compose simplifies the control of your entire application stack, making it easy to manage services, networks, and volumes in a single YAML configuration file. Then, with a single command, you create and start all the services from your configuration file.

Compose works in all environments - production, staging, development, testing, as well as CI workflows. It also has commands for managing the whole lifecycle of your application:

Start, stop, and rebuild services
View the status of running services
Stream the log output of running services
Run a one-off command on a service








What is YML file ?
YAML is a subset of JSON, so you can also use JSON. 







Explain Docker Compose File;


version: "3.8"

services:
  web-fe:
    build: .
    command: python app.py
    ports:
      - target: 5000
        published: 5000
    networks:
      - counter-net
    volumes:
      - type: volume
        source: counter-vol
        target: /code

  redis:
    image: redis:alpine
    networks:
      - counter-net

networks:
  counter-net:

volumes:
  counter-vol:



